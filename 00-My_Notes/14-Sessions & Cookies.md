# S14 | Module Introduction
---
<img src="./assets/S14/1.png" alt="packages" width="800"/>

# S14 | What is a cookie
---
<img src="./assets/S14/2.png" alt="packages" width="800"/>
- Example - In a login page the users sends a request to the server with the login information. 
- The server then sends back the response as a new view/page with a cookie which contains the information that the user is logged in. 
- This will enable the user to send subsequest request without logging in again. 

## Notes 
So what is a cookie? Well here's our setup, we got a user using browser and we got our server where our node application runs on. Now the user interacts with the frontend with the views we render with the ejs templating engine in this course but of course I'm talking about any views you might be rendering in your project with which ever templating engine you are using and from inside that view, let's say we have a form there to add a new product, we submit a request to our node server. Now let's say that request requires us to store some kind of data in the browser, let's say we're not working with the add product page but let's say we have a login page and when the user logs in, we want to store the information that the user is logged in somewhere so that when the user reloads the page and therefore technically a new request is sent, we still have that information around that the user is logged in and for that, we can send back a cookie with the response we send back upon the request. So the user submits the login data and we return a response which can be a new view to which we redirect to user but we also include our cookie and that cookie simply is important to well telling the user or to storing that information that the user is authenticated. We can store that information in the browser, so in the frontend so to say, in the environment the user interacts with and we can send this with subsequent requests to include the cookie there to send the data we stored in the cookie, like for example that information that we are logged in to the server, so cookies are stored on the client side. Now this is really abstract, let's simply try it out in our application.

# S14 | The Current Project Status
---
Download current project folder
<img src="./assets/S14/3.png" alt="packages" width="800"/>
- With current code project looks like this
- see that a login nav was added
- Login page is a typical use case for Session and Cookies 

<img src="./assets/S14/4.png" alt="packages" width="800"/>
- New Navigation!

## Notes
If you download the attached project snapshot which is my latest snapshot, you will see some differences there, so you should download it and what did I change and of course you can also go ahead and just implement these changes in your project. Well I commented out my links to the add product and admin products pages in my navigation.ejs file and I added a new unordered list after the first one and there I added a new list item which is named login. And then I also worked on the styles a bit and most importantly in the styles, I had changed my main header nav to be of type display flex, header width of 100% and justify content space between but again you find these files attached to this video. Now this leads to a setup where two navigation items are missing but the login button was added and it's on the right here due to that space between thing. Now why did I add this? Because I want to have some dummy login page. We'll have a complete module on authentication where we dive deeper into all that is related to authenticating but here authentication is a great example for data you would want to store for a specific user and that is one of the typical use cases for using cookies and sessions hence I want to use some dummy authentication in this module already. So what can we do with that? Well with that login button, we navigate if we have a look at navigation.ejs, we navigate to /login and that is a route which does not exist yet, we got no routes for logging in or signing up or anything like that. So I want to add this and if you don't want to practice this, again if that's not interesting to you, you can simply skip the next video, you can skip it and download the finished adjustments, the finished code after that next video so that you can continue with that. So in the next video, we'll implement that login screen, it's a great practice for you, you can also try it on your own before diving into my lecture where we do it together. And if you want to continue with cookies, immediately you skip the next lecture, you download the finished code and continue with that.

# S14 | Optional: Creating the Login Form
---
<img src="./assets/S14/5.png" alt="packages" width="800"/>
<img src="./assets/S14/6.png" alt="packages" width="800"/>
<img src="./assets/S14/7.png" alt="packages" width="800"/>
<img src="./assets/S14/8.png" alt="packages" width="800"/>
<img src="./assets/S14/9.png" alt="packages" width="800"/>
<img src="./assets/S14/10.png" alt="packages" width="800"/>
<img src="./assets/S14/11.png" alt="packages" width="800"/>
<img src="./assets/S14/12.png" alt="packages" width="800"/>
<img src="./assets/S14/13.png" alt="packages" width="800"/>
<img src="./assets/S14/14.png" alt="packages" width="800"/>
<img src="./assets/S14/15.png" alt="packages" width="800"/>
<img src="./assets/S14/16.png" alt="packages" width="800"/>

## Notes 
So let's work on that login page and for that I'll first of all add a new routes file which I'll name auth.js and in there, I want to manage my authentication related routes. Now for that, I will first of all set this up in a similar way to my other route files which means I will set up the express router, so let me simply create that here, we don't need the admin control though, so we have that router and I'll then export that router and for now I need one get route in here. A get route for /login then which will load the login page, so /login is what I want to handle here and as always, we have our request response next function here for handling that incoming request. Now in order to reach that route, we of course need to register it in the app.js file and in app.js, first of all let's import that route, so I'll duplicate my shop routes, name them auth routes, the name is up to you of course and it's in the auth file in the routes folder, so that file we just added and with the auth routes added there, I will simply add them below my shop routes. Just like the shop routes, I have no leading filter so every request will go in there and anything which is not found in the shop routes will therefore go into the auth routes and in the auth routes, I will handle /login, this route here. Now in here I simply want to render a page and I want to render a page in the let's say auth folder and just as I do this in the shop controller here, I will also create an auth controller for that. So let's maybe duplicate this get orders action from the shop controller, add it here and let's name it get login and then I don't need to find any orders or anything like that, that of course can be removed, I just want to render something, I want to render auth login here, the path will be /login, your orders well I will simply name this login and I don't pass any other data. So it's a really simple controller action in my auth.js file and with that in the auth.js file in the routes folder, I can simply import that, so here I will import my auth controller by requiring that from the controllers folder in the, whoops, the auth file there and then here for login, I will not use that function but point at my controller with the get login function. Ok so now we get the same setup we used for the other routes and now we have that login controller action which will render the login page with the appropriate title. Now let me head over to navigation.ejs real quick and make sure that this gets highlighted when we are on the page and for that I will copy that class assignments, that css class assignment, add it here and the path should be /login or whatever you assigned in your controller action. With that out of the way, let's add that folder and file in the views folder, so I'll add an auth folder here and in there a login.ejs file because that is just what I try to render my controller right, there I try to render auth login. so we need to have that path and file in our views folder. And for that I will really just use my product excuse me, my admin, my edit product page because there I have a form and I will move that into the login.ejs file, I will include head.ejs, I don't need the product.css but I need the forms.css . I will include the navigation, then this here will receive a new class, we can name this login form and see how we have to adjust the styling for that then. The action here, well that action will always be the same, we don't have different modes here, the action is always login and we send a post request to that login route. And then here let's say we have an email address, we name that field email here and we give it an ID of email, it's also of type email and not of type text and let's not start with a default value, so we don't need that here and we also need a password let's say, so let's add password here, name this password and give it an ID of password and the type here will also be password so that the characters are hidden and with that, we get also rid of this value here. Now we don't need the other form controls so we can get rid of these form controls, slso of the hidden one for now and let's simply add a button at the bottom which is of type submit and which simply says login, so a really simple form. With all of that in place, if we now click onto that login button, we are indeed loading that login page. Now the styling is a bit off because we need to style that login form and for that, I'll real quick add a new css file which I'll name auth.css and in there on the login form, let's have a look at the product form, I think we can just reuse that style here and yes we could have therefore also like refactored it into a global style but I'll just do it like this. And in login.ejs, we now just make do, need to make sure that we do also import that new auth.css file I just added. So if you now reload this, this looks pretty good. So now we got this in place and as I mentioned, I will not implement a full login flow right now, we'll do that in the next module where we dive into authentication and everything that belongs to it. But here I want to show you how we can use a cookie to save the information that this user is logged in and for that, we'll continue in the next lecture and see how we can use cookies. 

# S14 | Adding the Request Driven Login Solution
---
<img src="./assets/S14/17.png" alt="packages" width="800"/>
<img src="./assets/S14/18.png" alt="packages" width="800"/>
<img src="./assets/S14/19.png" alt="packages" width="800"/>
<img src="./assets/S14/20.png" alt="packages" width="800"/>
<img src="./assets/S14/21.png" alt="packages" width="800"/>
<img src="./assets/S14/22.png" alt="packages" width="800"/>
<img src="./assets/S14/23.png" alt="packages" width="800"/>
<img src="./assets/S14/24.png" alt="packages" width="800"/>
<img src="./assets/S14/25.png" alt="packages" width="800"/>

## Notes
So in the last lecture we edit this login form which you can reach by clicking on login here on the top right corner and you can simply download the attached code to have that same starting project, if you download it just make sure that you use your database credentials here when connecting to the database because mine won't work for you obviously because I shut down the server after I'm done recording. So I added this login page and we'll not implement authentication right now, we'll do this in a separate module but this is a great dummy scenario for using a cookie because let's say when we click that submit button here, the login button, we will actually send a login request to the backend because that is what we stored in the login form, here in auth login, we are sending a post request to /login and since we do that, we should handle this and we want to in a real scenario validate the e-mail and password, in this module we'll not do that, we'll just assume that the input data is valid because it's not the topic we'll focus on for now. So let's add a new controller action first of all in the auth.js file and I'll name it post login. Now in post login, I will get my login data, e-mail, password and so on and I don't really care about that data, so I'll just assume the user is logged in and I will then redirect to just slash. However and now that is important, if we do it like this and we add a route for this of course to our auth route file, so here this is post, a post request to /login and we use the post login controller action, if I do this and then click on login here, I am indeed forwarded to the /route. Ok so this could mean we are authenticated. Now let's say we want to store that information that the user is authenticated, how could we store that? Well you could say I go into my controller and in post login where I do log the user in, I store that information in my request object, is logged in because we are already doing a similar thing in app.js right at the start, we fetch our one dummy user and store that in the request so that we can use it for the rest of that request, so in all the routes and controllers where we handle that request. We can do the same here and set this to true, by default right at the start it will not be set, so the value will be undefined which is treated as false and that is the information I need. Now to validate whether that works, let's actually go to our views and there in the navigation.ejs, I commented out two routes for which we could say we need the user to be authenticated, let's comment them in but only render them if the user is authenticated. So how would we go about that? Well we could use ejs for that of course and we can check if, let's say we expect to get some isAuthenticated value here, so if isAuthenticated then we'll do something, we'll render this part here and otherwise this will not be rendered because we don't make it into that if block. So if I do it like this and I reload this page, I get an error that isAuthenticated is not defined because we're not always rendering this to our different views. So what we actually need to do since the authentication is part of every page, for every render call here, we need to pass the information whether the user is authenticated or not and for that I'll access request is authenticated because that is exactly or is logged in, excuse me is logged in because that is the field we're storing that information. So I'll access request is logged in because that is what I will set to true when we do login, so I'll add isAuthenticated and store that value to every render call here. Here and here for get add product, also on the error page here like this and also in shop.ejs of course for all our routes here like this one, basically every time when we call render, in all these cases I will add my isAuthenticated information. So now that I added it to all routes and I saved all files, if I reload I still fail because I obviously also need to render, I need to add it to auth.js, to my render route there, so now if I reload, this works and we are missing these two fields. If I login, we are still missing them though and why is that, do you know why this does not work? Even though I am storing the information that I am logged in, in is logged in when we click that button, I'm storing it in my request and then I use that information in the request on every other route I handle and I pass it into isAuthenticated which is the field which I'm using in my frontend, in my navigation, there I am checking for isAuthenticated and that is what I am passing to that frontend in my render calls here. Well the problem of course is yes I update is logged in here in the request and what happens to the request once I send a response and we do send a response by redirecting? Well the request is dead, it's done. With a response, we basically finished a request, we got a request and we sent a response, we're done. This data does not stick around, this data is lost after the request or after we send the response. So whenever we visit a different page, like here where we do get redirected, so we get redirected here and we reach our get index action here in the end and there, we do render the shop index page but this is a brand new request, the redirection creates a brand new request and this is super important to understand. We're working with totally separate requests and that is important because your application, your page will have hundreds of users and obviously the requests of all these users are not related to each other otherwise they could maybe look into data that they shouldn't see and even the requests of a single user, so requests made from the same IP address are treated as totally independent requests. They are not seen in a bigger context or anything like that and this is a good thing, this is deliberately designed that way and therefore any data we store here can be used as long as we are working on the same request. That is why when we retrieve the user in app.js here and I store it in the request, that is why we still can use that request user in all our action controllers because they can again at a later point of time, this middleware runs on every incoming request before our routes handle it. So the data we store here is used in the same request cycle, in our route handlers in our controllers but if I do change the request at the end of its lifetime, like here, right before I send the response, this data will not be useful to us, it's really important to understand this. So let's now see how we could solve this in a better way.

# S14 | Setting a Cookie
---
## req.get(field)
Returns the specified HTTP request header field (case-insensitive match). The Referrer and Referer fields are interchangeable.
```js
req.get('Content-Type');
// => "text/plain"

req.get('content-type');
// => "text/plain"

req.get('Something');
// => undefined
```

<img src="./assets/S14/26.png" alt="packages" width="800"/>
- Please see Section-6 (Sharing Data Across Requests and Across Users) for details on how to achive this. 

Using global variable solution to show the navigations
<img src="./assets/S14/73.png" alt="packages" width="800"/>
<img src="./assets/S14/74.png" alt="packages" width="800"/>
<img src="./assets/S14/75.png" alt="packages" width="800"/>
<img src="./assets/S14/76.png" alt="packages" width="800"/>
<img src="./assets/S14/77.png" alt="packages" width="800"/>


<img src="./assets/S14/27.png" alt="packages" width="800"/>
<img src="./assets/S14/28.png" alt="packages" width="800"/>
<img src="./assets/S14/29.png" alt="packages" width="800"/>
<img src="./assets/S14/30.png" alt="packages" width="800"/>
<img src="./assets/S14/31.png" alt="packages" width="800"/>
<img src="./assets/S14/32.png" alt="packages" width="800"/>
<img src="./assets/S14/33.png" alt="packages" width="800"/>
<img src="./assets/S14/34.png" alt="packages" width="800"/>

## Notes
So we found out that using a request for storing this is not ideal because the request is dead after sending a response, which alternatives do we have? Well one alternative would be some kind of global variable. You could use a global variable which you store in an extra file and which you export from that file and which you then change and that variable would actually survive your request cycles but since that variable would be shared across all requests, it would also be shared across all users and that is exactly where cookies can help us. With cookies we can store data in the browser of a single user and store data in that browser which is customized to that user which does not affect all the other users but can be sent with requests to tell us hey I already am authenticated and that is exactly what we will do here. So instead of just redirecting here, what we can do is we can set a cookie and we set such a cookie simply by setting a header. So we set a header on our response and we set a header here by first of all defining the name of the header and the name is set cookie indeed, that is a reserved name which well sets a cookie and then you have the value of that header and the value for set cookie in its simplest form is simply a key value pair where you define any name you want and any value you want. So you could have something like logged in or logged in, makes it easier to read equals true, this would set a cookie and I can show this to you. If you now save this and you go to the login page and you click post here or click login, open your developer tools and in the chrome developer tools, you can go to the application tab and there to cookies and if you expand this, you should see your current address here and if you click on that, you will see some cookies. Now some cookies will be set by third party plugins, chrome extensions and so on but you will also see logged in and the value true, you should see that at least and that is the cookie we just set. Let me zoom out a bit here, there you see the domain to which it belongs, the path, when it will expire and this state is in the past because it's a so-called session cookie, it will basically expire once you close the browser and come back, you see the size and some other information to which I will come back in a second. So this cookie is now set and now this cookie is not only set but the browser by default sends it to the server with every request we make, so if I click on products here for example, we go to the network tab, this is the request which was sent to the products page and there if we have a look at the headers and we scroll down to the request headers, you see that a cookie was sent. The first one comes from an extension but here this is our cookie, so it was sent to our server and now since we have that, every request will have that cookie attached to itself and therefore this data is sent with every request and now we can use that. Let's start simple, let's say in the get login page here. We can have a look at our headers, let me console log request get and then you enter the header name which is cookie because remember in the client side dev tools, you saw that the cookie header was sent with the request and now if you go to the login page or reload that page if you are on it, I reloaded it a couple of times, you see this output. Now we can ignore the first cookie but this is our logged in cookie and now we could extract that value for example by splitting on the semi-colon and then taking the second value in that array, the array index starts at zero so one gives us the second element and now if I reload this, you see I get logged in true here, you could trim that to remove any excess white spaces, we could split this again on the equal sign, this is obviously a very complex way but if I do this again and then I use the second value, then I should get the true or false value. So now if I reload this, I get true here, so obviously this is a very complex way but should be quite readable and then I can extract my is logged in information from the incoming request header, I'm getting the cookie header, I make sure that I get the second cookie that is sent which happens to be our is logged in cookie. If you only have one cookie being sent by the way, then make sure you extract the first value, so whatever or wherever is logged in is located for you, if you only have one cookie, use the first one with zero, if you've got multiple ones, use the third one and so on and then I extract the true value and now I have that is logged in information which I can pass to isAuthenticated. And with that on that page, if I now reload it, hey here are our two options in the menu because now we do enable that again because now we store that information across requests. So now even if I navigate away to another page or I don't extract that cookie yet and I come back to login, there I do extract it and it is always sent with every request, so it is a cross request data storage. Still there is a big disadvantage and do you know which one that is? 

# S14 | Manipulating Cookies
---
<img src="./assets/S14/35.png" alt="packages" width="800"/>
<img src="./assets/S14/36.png" alt="packages" width="800"/>
<img src="./assets/S14/37.png" alt="packages" width="800"/>

## Notes 
So in the last lecture I showed you how you can set a cookie and some a bit too complex way of extracting that cookie. Now if you want to extract cookies by the way, there also are third party packages which can help you with that but our approach has another flaw. Well obviously since I can access my cookies that easily in the developer tools, I can easily change them, I can go here and manipulate the value, for example if I set it to false and I reload, I'm actually still logged in because false is sent as text and text is always treated as true but we can simply add a comparison here and see if that value is equal to true, so to the text true here and now if I reload here, I'm not logged in anymore. If I change it back to true though and I do reload, I am. So the issue here is we can manipulate that from inside the browser and obviously you don't want to allow the users of your website to login by simply manipulating some cookie value. So whilst it is certainly interesting to store some data in the client side, especially things that are related to tracking users, advertisements tracking and so on, whilst this is interesting, sensitive data should not be stored in the browser because users can edit them as you see, we can edit our logged in cookie. So whilst cookies are generally a good thing for storing data across requests, it might not be the best approach in all scenarios and that is exactly something where sessions can help us with. However before we dive into sessions, let me quickly explain you some other fields you can configure about a cookie which will also highlight when a cookie does make sense to be used before we then dive into the scenario where it's not the best tool. 

# S14 | Configuring Cookies
---
For example for tracking users, cookies is a popular instrument.
Because as you can for example see with the cookies I have here, the cookies don't only have to relate
to your page. A cookie can also be sent to another page and that is a common instrument in tracking.

You can also configure cookies.
We set a value but actually you can set more things than just the value.

<img src="./assets/S14/38.png" alt="packages" width="800"/>
<img src="./assets/S14/39.png" alt="packages" width="800"/>
<img src="./assets/S14/40.png" alt="packages" width="800"/>
<img src="./assets/S14/41.png" alt="packages" width="800"/>
<img src="./assets/S14/42.png" alt="packages" width="800"/>
<img src="./assets/S14/43.png" alt="packages" width="800"/>
<img src="./assets/S14/44.png" alt="packages" width="800"/>

## Notes 
So we can manipulate cookies so storing sensitive data is not ideal but I mentioned that for example for tracking users, it's a popular instrument and why is that? Because as you can for example see with the cookies I have here, the cookies don't only have to relate to your page. A cookie can also be sent to another page and that is a common instrument in tracking where you have that so-called tracking pixel on pages which is simply an image url with no real image but that image can be located on let's say Google's servers and you have a cookie on that page which is also sent along with that and therefore Google can track on which page you are and how you are moving through the web even if you're not on their websites because some data is stored in your client and obviously you could delete it therefore which is why you can block such mechanisms too but it is stored there and it is sent with every request to Google, so they can track you without you being on their servers, so storing that information on their servers would not work but storing it on your computer will work because obviously that can be sent on every page you visit. So that is something where this could be interesting if you want to track your users, that is a very common thing to do and you can also configure cookies. We set a value but actually you can set more things than just the value, here I set my cookie by adding that key value pair. Now obviously we could add multiple cookies, multiple key value pairs, we can also add a semi-colon after the key value pair and for example set expires to some expiration date, this date would have to follow a certain format, the http date format, I'll link it attached to this video here. So you could set a certain date when this cookie will expire because remember if you don't set this, it will expire once you close your browser. Alternatively to expires, you can set max age written like this and this is a number in seconds, how long that cookie should stay around, so we could set this to 10 for example and now if I click that login button here, I got logged in and now you see the expiry date also changed here, the expiry date if I decrease that, the expiry date here basically is today and now it already is expired and if I reload that page, is logged in is therefore gone. So this is something we can do and this is of course interesting if you want to control for example how long you want to track a user or we will actually use that together with authentication later, you could use this to also control how long an authenticated session stays active for a user, you might know that from your online bank where you timeout after a certain duration. You can also add a domain to which the cookies should be sent and here we again are on that tracking thing again. You can add secure just like this without an equal sign, just secure, this means this cookie will only be set if the page is served via https. Now I can't demonstrate this here because our local development server is not using https but we will eventually use https later in the course where I will show you how to set this up, so now you can already see however that I get an error if I try to reload login because I try to extract the value which is not there. So for now let's simply comment this out and set this always to false so that I can just show you how this cookie is now not set, if I reload and I click here, you don't see the cookie here because I added secure and it would only be set if we are serving the page via https and you can also set this to http only. Now if I do that and I go back to login and I click here, it is set but now it has this checkmark here in the http column and that means that now we can't access the cookie value through client side javascript, so in the scripts running in the browser. This can be an important security mechanism because it protects us against cross-site scripting attacks now because now your client side javascript where someone could have injected malicious code can't read your cookie values and that will be important later with authentication where a cookie will not store the sensitive information but an important part of authenticating the user. So this can be an extra security layer because now the cookie will still be attached to every request that is sent to the server but you can't read the cookie value from inside the browser javascript code. Obviously as you can tell, as a user in the developer tools, you can still read it but then again it's your own cookie and you will not store information like hey I'm logged in there because that would be easy to manipulate and you can't protect against that. These are the key values you can set here and this gives you a lot of flexibility. That being said, often you will not directly set your cookies because you rather use some packages like for example for authentication that will manage setting the cookie for you. And that is something which I'll dive into in the next lectures where we dive into sessions, what sessions are, how they can help us with storing sensitive information across requests and how cookies still are important when using sessions.

# S14 | What is a Session
---

## Notes
<img src="./assets/S14/45.png" alt="packages" width="800"/>
What is a session? Well we have the same set up as before, user using the frontend our view is interacting with our server where we have our node application code. We send a request and we do login and again let's assume we do send the valid credentials there, we're not validating them in this module because I want to focus on sessions and cookies. So now instead of storing the information that the user is authenticated in the frontend which was a bad place as we learned, we'll store it in the backend with a so-called session and a session is a new construct which we haven't used before. With that I'm not meaning that we store it in the request because we already saw that this will not work and I also don't mean that we store it in some variable in our express app because that would be shared across all users and all requests, we only want to share the information across all requests of the same user and that's really important, the same user so that other users can't see your data, can't assume your role, can't tell the server that they are authenticated, only you are authenticated. Now for that, we need to store it on the server, we'll start by storing it in memory which is then pretty similar to storing in that variable but eventually we'll move to a different session storage, the database. We need one important piece of information. A client needs to tell the server to which session he belongs because the session will in the end just be an entry stored in memory or stored in a database. 

Now we're not matching this by IP address or anything like that because that is a bit hard to maintain and can be faked and all that fun stuff,so we're not doing that instead we'll use a cookie where we will store the ID of the session. Now obviously you can still change that and assume a different ID if you want to but that will not work like this because actually the value we store will not be the ID but the hashed ID, hashed with a certain algorithm where only the server can confirm that it has not been fiddled with so that you didn't play around with it and tried to create a different one. So this will be a secure way because you basically store the ID in an encrypted way where only the server is able to confirm that the stored cookie value relates to a certain ID in the database and therefore we got a safe value stored in the cookie which you can't, you can change it but you will not assume a different session, a session can be matched and that session can then contain the confidential data which you can't change from inside the browser, that is the idea here. So sessions are stored on the server side, cookies client side, sessions server side. Now let me show you how to implement a session.

# S14 | Initializing the Session Middleware
---

## Notes 
<img src="./assets/S14/46.png" alt="packages" width="800"/>
<img src="./assets/S14/47.png" alt="packages" width="800"/>

To implement a session, we'll need another third party package, we'll need another package which helps us with managing sessions. For that we'll install it with npm install --save and the package is named express-session, it's a package which is actually part of the official expressjs suite but not baked into expressjs itself but now we already got it installed and now we're ready to use it. To use it, we'll go to our app.js file because we want to initialize that session early on, we want to initialize that session when we, well when we start up our server then we want to initialize the session middleware at least and the session will then be used for every incoming request. So in here we create a new constant, so we basically import something here which I'll name session, the name is up to you and I will require express session, that is what I'll require here, so that is the package we just installed. Now with that installed, we can set it up here along with the other middleware let's say.

<img src="./assets/S14/48.png" alt="packages" width="800"/>
There we register another middleware with app use and to app use, we pass session and we execute this as a function and to the function, we pass a javascript object where we configure the session setup. For example we need to set a secret, this will be used for signing the hash which secretly stores our ID in the cookie. So here I'll set a secret, you can enter any text here, it should typically be a long string, I'll name it my secret but again in production, this should be a long string value. Then you should add the re-save option and set this to false, this means that the session will not be saved on every request that is done, so on every response that is sent but only if something changed in the session., this will obviously improve performance and so on. Also there is the save uninitialized value which you should set to false because this will also basically ensure that no session gets saved for a request where it doesn't need to be saved because nothing was changed about it and that is it. These are the core things you need to set. You could for example also configure the session cookie, you could give it a max age by setting a date or add the expires key, so you can configure that cookie but you can also go with the default settings. And with that, the session middleware is initialized and we're now ready to use the session. Now let's start using it in the next lecture.

# S14 | Using the Session Middleware
---
## Notes 
<img src="./assets/S14/49.png" alt="packages" width="800"/>
<img src="./assets/S14/50.png" alt="packages" width="800"/>
<img src="./assets/S14/51.png" alt="packages" width="800"/>
<img src="./assets/S14/52.png" alt="packages" width="800"/>
<img src="./assets/S14/53.png" alt="packages" width="800"/>
<img src="./assets/S14/54.png" alt="packages" width="800"/>
<img src="./assets/S14/55.png" alt="packages" width="800"/>
<img src="./assets/S14/56.png" alt="packages" width="800"/>
<img src="./assets/S14/57.png" alt="packages" width="800"/>

So we added the session middleware, let's now start our server again and let's use the session middleware and how do we use it? Well we can use it in our auth controller in login instead of setting that cookie, we can reach out to request and then the session object, this is added by the session middleware, this session object and here we can add any key we want, for example is logged in but you can name this however you want and set this to true. Now if you save that and you go back to your browser, go to the login page maybe, reload and get rid of that logged in cookie, you can simply delete it here. Now click login and what you should see is that a new cookie was added here, this connect SID for a session id cookie, if you expand the value here, you'll see some strange string and that is what I meant, this is this encrypted value so to say. And this is now the cookie, by default it's a session cookie so it will expire when you close the browser. 

It's a session cookie that will identify your user here, your running instance of this website you could say where you are browsing around, this will identify you to the server and to this session and I can prove this to you. If we now go to the get login page here and I console log requests session here like that, let me then go back and click on the login page here again and go back to our server and there you see the session object is logged. Now let me also output is logged in here by accessing that, go back, login again, it's undefined because I added the this code only after submitting this for the first time, so let me save this again and now simply click that login button here again and now you will see if you go back to the login page, you see true here because now indeed in the session is logged in is stored. And we can go to a different page and come back to login and these are all individual requests which technically are totally individual from each other, totally separated and still we see true here because we still store this in the session on the server side by default, just in the memory not in the database yet and the session is identified for this browser because we have that cookie. 

And I can prove that to you by starting another browser and this will technically be treated as a totally different session and environment, could be a totally different machine. So I am on localhost 3000 here and if I click on login here, you see undefined and that undefined is coming from the login request I just sent because this browser, this user, technically this is a totally different user even though I'm the same but it's a different browser, different user, this user does not have this cookie set for him, does not have an active session on the server. And this is how we can store data that persists across requests as you saw, I clicked around and still that was sent, the true value was sent when I came back to log in, so this is saved across requests but not across users, as you can see this is a different user, I go to login, I have undefined down there and that is the power of using a session. 

It still needs a cookie to identify the user but the sensitive information is stored on the server, we can't modify it and that of course will be super important for authentication and what we see here already is the core mechanism behind authenticating users in the web. There are other techniques too, for example when building a rest API, something I'll come back later but this is a core thing on how authentication generally works especially when rendering views as we are doing it with ejs and this is what we will build up on in the authentication section where we then also dive into things like validating credentials, logging users out and fun stuff like that.


# S14 | Using MongoDB to Store Sessions
---
## Notes 
<img src="./assets/S14/58.png" alt="packages" width="800"/>
<img src="./assets/S14/59.png" alt="packages" width="800"/>
<img src="./assets/S14/60.png" alt="packages" width="800"/>
<img src="./assets/S14/61.png" alt="packages" width="800"/>
<img src="./assets/S14/62.png" alt="packages" width="800"/>
<img src="./assets/S14/63.png" alt="packages" width="800"/>
<img src="./assets/S14/64.png" alt="packages" width="800"/>
<img src="./assets/S14/65.png" alt="packages" width="800"/>
<img src="./assets/S14/66.png" alt="packages" width="800"/>
<img src="./assets/S14/67.png" alt="packages" width="800"/>
<img src="./assets/S14/68.png" alt="packages" width="800"/>
<img src="./assets/S14/69.png" alt="packages" width="800"/>
<img src="./assets/S14/70.png" alt="packages" width="800"/>
Now I showed you how to use a session, the problem here is this session is stored in memory and memory is not an infinite resource. So for development, this is fine but for a production server, this would be horrible because if you have thousands or one hundred thousands of users, your memory will quickly overflow if you store all that information in memory. You don't want to do that, from a security perspective, it's also not ideal. So we want to store sessions differently and on the express session documentation, so on the docs, on the github page of that package we're using, if you scroll down to the end, you will find a list of session stores you can use and basically all kinds of databases are supported. You could store it in files though that might not give you the best performance and we will use mongodb because we are already using that right and for that, we'll use the connect mongodb session package here, so we'll install this package now and register this as a store with which we can work. 

So back here in our project, let me quit the server with control c and let's first of all install that package with npm install --save connect -mongodb-session and this will download this package which we can use to let our express session package store data in the database. So now it is installed, we can restart our server and now let's go to app.js where we do initialize our session, here we do configure the session and this is also where we need to configure our store. Now to set up that store, first of all I'll import mongodb store, you can name this however you want and I will require connect mongodb session. Now this actually gives you a function which should execute to which you pass your session, so this session object you're importing from express session is passed to a function which is yielded by required connect mongodb session and the result of that function call is stored in mongodb store. Now with that, you can initialize a new store, store it in a constant named store maybe, that name is up to you and you execute mongodb store as a constructor because this function happens to yield a constructor function which we store in mongodb store. 

To that constructor, you pass some options and now which options could that database store require? Well it will require a connection string because it needs to know in which database, on which database server to store your data. Now we have a connection string down there, so I'll copy that entire url and cut it actually and I will store it in a constant up here, I'll name it mongodb URI, all capital case to signal that this is basically a constant value which I'll reuse and then here, I will use my mongodb URI and I will also use it down there. Please note that the session now will also be stored in a shop database, you could use a different database but then you need to use two different urls, I'm fine with using the same database. I will define the collection though and you need to to define the collection where your sessions will be stored and I will name it sessions but the name is up to you, you could name this however you want. Now you could also add more information, like for example when this should expire and then it can be cleaned up automatically by mongodb but I will set it up like this and now I have my store added here and when I saved, I get an error actually. This can be fixed by removing that retry writes here at the end of the URL, if you do that, it should work. 

So now we get the store set up here and now we can use that store as a session store and to use it, we go to the place where we initialize our session down there and we add another option, the store option and we set it equal to our store constant or whatever you named the constant where you store that initialized mongodb store and with that, your session data will be stored in there. So if I now go back to my page and I do click that login button again, I got a new session, a new session cookie and that session will now be stored in mongodb and we can of course validate that by starting mongodb compass to look into our database. There if you look into your shop database, you will find a sessions collection and in the sessions collection, you'll find a session with an ID and in that session, you'll find that information like is logged in and some information about the cookie which belongs to that session, also you find the expiry date that was set by default. 

So this is how sessions are now stored and this is how you should store them for production, use a real session store, don't use the memory store which is less secure and which also is less unlimited or which will reach limits when more users use your app. But with that sessions are a powerful tool for storing data across requests while still scoping them to a single user and not sharing the data across users because now as you saw, different users have different sessions but this is now a great way mostly for managing authentication but you could also store something like the shopping cart in a session. We are storing it in a database which is also a decent solution but you could store it in a session and therefore indirectly in the database I guess, in the session database collection but you could use a session for something like this. So in general, use a session for any data that belongs to a user that you don't want to lose after every response you send and that should not be visible to other users.

# S14 | Sessions & Cookies - A Short Summary
---
## Notes 
<img src="./assets/S14/71.png" alt="packages" width="800"/>
<img src="./assets/S14/72.png" alt="packages" width="800"/>
So now we had a look at how we can use sessions and what the advantage of a session is and we also of course learned about cookies, what a cookie can be used for and how it plays together nicely with a session to identify a user, a client and then store the sensitive data on the server, so in the session and that difference between the sessions server side and cookies, client side is really important to understand and you also learned how to set a cookie and how to use a session. Now by the way if you're wondering how that session cookie, this cookie here, how this is set, well this is done automatically by express session so by that middleware we're configuring and that's also why you can add cookie related configurations here because this middleware automatically sets a cookie for you and it automatically reads the cookie value for you too, so it does all the cookie parsing and setting for you. Now with that, you actually rarely need to manage cookies on your own because that session cookie and with that I don't mean a cookie which gets lost after you close the browser but that cookie that identifies a server side session, that is the most prominent, the most common use case for cookies besides advertisement, tracking which you typically don't implement on your own but you use third party tools like Google for that. But that session cookie, so that session identifying cookie is an important thing and sessions on the server are often used for authentication but as I mentioned, you could use them for any kind of data you want to store. We happen to store the information whether the user is logged in but you could be storing the carts, the shopping cart of the user here or anything which belongs to a user which should be shared across requests as I highlighted.